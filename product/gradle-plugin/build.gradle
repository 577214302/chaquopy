import com.chaquo.python.Common;

apply plugin: 'groovy'

group = "com.chaquo.python"

dependencies {
    implementation localGroovy()
    implementation gradleApi()
    implementation "org.apache.commons:commons-compress:1.18"
    implementation "org.json:json:20160810"

    testImplementation "junit:junit:4.12"
}

sourceCompatibility = 7
sourceSets.main.java.srcDirs += ["../buildSrc/src/main/java"]

task("zipBuildPackages", type: Zip) {
    destinationDirectory = file("$buildDir/tmp/$name")
    archiveFileName = "build-packages.zip"
    from "src/main/python"
    exclude "**/*.pyc"
}

processResources {
    doFirst { delete destinationDir }
    into("com/chaquo/python/gradle") {
        from zipBuildPackages
    }
}

// Don't use the Exec task: on Windows, it causes the integration tests to hang if they spawn a
// Gradle daemon, because their stdout is inherited by the daemon and will therefore never
// close (https://github.com/gradle/gradle/issues/3987). This can be reproduced more simply
// with the command `cmd /c start notepad.exe`: cmd will exit, but the Exec task won't
// complete until you close Notepad.
Task testPythonTask(String name, String version, Closure closure) {
    def t = task(name, "group": "verification") {
        def pb = new ProcessBuilder()
        def command = new ArrayList<String>()

        // Emulate the necessary Exec methods.
        ext.workingDir = { dir -> pb.directory(file(dir)) }
        ext.environment = { String key, String value -> pb.environment().put(key, value) }
        ext.args = { String... args -> command.addAll(args) }

        if (System.properties['os.name'].toLowerCase().contains('windows')) {
            args "py", "-$version"
        } else {
            args "python$version"
        }
        args "-m", "unittest"
        if (project.hasProperty("testPythonArgs")) {
            args project.testPythonArgs.split(" ")
        } else {
            args "discover", "-v"
        }

        outputs.upToDateWhen { false }
        doLast {
            pb.command(command)
            pb.redirectErrorStream(true)  // Merge stdout and stderr.
            def process = pb.start()

            // pb.inheritIO() doesn't seem to prevent stdout from blocking. Even if it did, the
            // output would be lost because it would inherit the Gradle daemon's *native*
            // stdout, which isn't connected to anything.
            //
            // So we capture the output manually and send it to System.out, which is connected
            // to the Gradle client. In case isAlive() returns true with data still buffered,
            // we keep on reading after the process exits until no more data is available.
            def stdout = process.getInputStream()  // sic
            def buffer = new byte[1024]
            def available = 0
            while ((available = stdout.available()) > 0 || process.isAlive()) {
                if (available > 0) {
                    def len = stdout.read(buffer, 0, Math.min(available, buffer.length))
                    System.out.write(buffer, 0, len)
                    System.out.flush()
                } else {
                    Thread.sleep(100)
                }
            }
            def status = process.waitFor()
            if (status != 0) {
                throw new GradleException("Exit status $status")
            }
        }
    }
    closure.delegate = t
    closure()
    return t
}

// Test on the minimum supported buildPython version.
testPythonTask("testPython", "3.5") {
    workingDir "$projectDir/src/test/python"
}
check.dependsOn(testPython)

/** @param version Android Gradle plugin version (corresponds to directory
 *  test/integration/data/base-$version) */
Task testIntegrationTask(String version) {
    return testPythonTask("testIntegration-$version", Common.PYTHON_VERSION_SHORT) {
        dependsOn publish, ":runtime:publish", ":proguard:publish"
        workingDir "$projectDir/src/test/integration"
        environment "AGP_VERSION", version
    }
}
task("testIntegration", "group": "verification")
for (version in ["3.4", "3.5", "3.6", "4.0", "4.1"]) {
    testIntegration.dependsOn(testIntegrationTask(version))
}
check.dependsOn(testIntegration)

jar {
    manifest {
        // Enables getClass().getPackage().getImplementationVersion(), which PythonPlugin uses
        // to discover its own version number.
        attributes 'Implementation-Version': project.version
    }
}

publishing.publications {
    gradle(MavenPublication) {
        from components.java
        artifactId = "gradle"
    }
}