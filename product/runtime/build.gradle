apply plugin: 'java'

import com.chaquo.python.Common;

group = "com.chaquo.python.runtime"


// See product/README.md for Windows build instructions.
def windowsHost = System.properties['os.name'].toLowerCase().contains('windows')
def EXE_SUFFIX = windowsHost ? ".exe" : ""
def mingwDir = windowsHost ? getLocalProperty('mingw.dir') : null

def pyPlusVersion = "python$Common.PYTHON_SUFFIX"
// filenames with dots require the ".exe" suffix with Exec tasks on Windows.
def pyPlusVersionExe = "$pyPlusVersion$EXE_SUFFIX"


void addArtifact(Task task, Object filename, String abi=null) {
    File f = file(filename)
    def dotPos = f.name.lastIndexOf(".")
    def name = f.name.substring(0, dotPos)
    def pub = publishing.publications.maybeCreate(name, MavenPublication)
    pub.artifactId = name
    pub.artifact(f) {
        builtBy task
        if (abi != null) {
            classifier abi
        }
        extension f.name.substring(dotPos + 1)
    }
}

sourceSets.main.java.srcDirs += ["../buildSrc/src/main/java"]
sourceCompatibility = 7
jar { archiveFileName = "chaquopy_java.jar" }
addArtifact(jar, jar.archivePath)

task("compilePython", type: Copy, group: "build") {
    doFirst {
        delete(destinationDir)
        mkdir(destinationDir)
    }
    from "src/main/python"
    into "$buildDir/$Common.ASSET_BOOTSTRAP"
    include "**/*.py"
    include "**/*.dist-info/**"  // For license files
    includeEmptyDirs false
    doLast {
        exec {
            // Run compileall from the parent directory: that way the "bootstrap/" prefix gets
            // encoded into the pyc files and will appear in traceback messages.
            workingDir destinationDir.parent
            executable pyPlusVersionExe
            args "-m", "compileall"
            args "-q", "-b", Common.ASSET_BOOTSTRAP
        }
        delete fileTree(destinationDir) {
            include "**/*.py"
        }
    }
}

task("zipPython", type: Zip, group: "build") {
    from compilePython
    destinationDirectory = buildDir
    archiveFileName = Common.assetZip(Common.ASSET_BOOTSTRAP)
}
addArtifact(zipPython, zipPython.archivePath)


// The following properties file should be created manually. It's also used in
// test_gradle_plugin.py.
String getLocalProperty(String key, String defaultValue = null) {
    def localProps = new Properties()
    localProps.load(project.rootProject.file('local.properties').newDataInputStream())
    def result = localProps.getProperty(key, defaultValue)
    if (result == null) {
        throw new GradleException("'$key' is missing from local.properties")
    }
    return result
}

def sdkDir = getLocalProperty('sdk.dir')
def ndkDir = getLocalProperty('ndk.dir')
def licenseMode = getLocalProperty('chaquopy.license_mode', '')

def javaHome = System.getProperty("java.home")
if (javaHome.endsWith("jre")) {
    javaHome += "/.."
}

task("doc", group: "documentation")

javadoc {
    outputs.upToDateWhen { false }
    destinationDir = file("$docsDir/java")
    title "Chaquopy Java API"
    options {
        addStringOption("source", "8")
        addBooleanOption("Xdoclint:all,-missing", true)
        addBooleanOption("nodeprecated", true)
        addStringOption("link", "https://developer.android.com/reference/")
    }
}
doc.dependsOn(javadoc)


def cythonTask = {Map taskArgs=[:], String name, Closure closure ->
    taskArgs["type"] = Exec
    taskArgs.putIfAbsent("group", "build")
    def t = task(taskArgs, name, closure)
    t.configure {
        def pyxFiles = inputs.files.findAll { it.name.endsWith(".pyx") }
        assert(pyxFiles.size() == 1)
        def inFile = pyxFiles.get(0)
        def stem = inFile.name.substring(0, inFile.name.length() - ".pyx".length())
        def outDir = "$buildDir/cython"
        def outFile = "$outDir/${stem}.c"
        outputs.file outFile

        doFirst {
            file("$outDir/build.pxi").text = "DEF CHAQUOPY_LICENSE_MODE = \"$licenseMode\""
        }
        workingDir inFile.parent  // Reduce clutter in exception traces
        executable "cython"
        args "-Wextra", "-Werror", inFile.name, "-I", outDir, "-o", outFile
        if (! licenseMode.isEmpty()) {
            args "-X", "emit_code_comments=False"
        }

        doLast {
            String[][] replacements = [
                // All functions called directly by the JVM must be declared JNICALL JNIEXPORT. JNIEXPORT
                // should be equivalent to Cython's "cdef public", but JNICALL does make a difference on
                // some platforms including x86. So alter the generated C code to add it.
                [/^__PYX_EXTERN_C (\w+)/,
                 '/* cythonTask altered */ __PYX_EXTERN_C JNIEXPORT $1 JNICALL'],

                // Workaround for https://github.com/cython/cython/issues/3725.
                [/__pyx_insert_code_object\(c_line/,
                 '// cythonTask disabled: $0'],
            ]
            def cFile = outputs.files.getSingleFile()
            def tmpFile = new File("${cFile}.tmp")
            tmpFile.withWriter { writer ->
                for (line in cFile.readLines()) {
                    for (r in replacements) {
                        line = line.replaceAll(r[0], r[1])
                    }
                    writer.write(line + "\n")
                }
            }
            if (! (cFile.delete() && tmpFile.renameTo(cFile))) {
                throw new GradleException("Failed to replace $cFile")
            }
        }

    }
    return t
}

cythonTask("cythonPython") {
    inputs.files fileTree("$projectDir/src/main/python/java") {
        include "chaquopy.pyx", "*.pxi", "*.pxd"
        exclude "chaquopy_android*"
    }
    inputs.property("licenseMode", licenseMode)
    if (licenseMode.isEmpty()) {
        inputs.files "$projectDir/../../server/license/check_ticket.py"
    }
}
cythonTask("cythonJava") {
    inputs.files fileTree("$projectDir/src/main/python") {
        include "chaquopy_java.pyx", "java/*.pxd"
    }
}
cythonTask("cythonAndroid") {
    inputs.files fileTree("$projectDir/src/main/python/java") {
        include "chaquopy_android*", "*.pxd"
    }
    inputs.property("licenseMode", licenseMode)
}

// With version 3.10.2.4988404, the cmakeBuild-host task alters build.ninja, which causes the
// slow cmake-host task to be rerun on every build.
def sdkCmakeDir = "$sdkDir/cmake/3.6.4111459"

def androidJar = "$sdkDir/platforms/android-$Common.COMPILE_SDK_VERSION/android.jar"
if (!file(androidJar).exists()) {
    throw new GradleException("Android SDK Platform $Common.COMPILE_SDK_VERSION not found: " +
                              "install it using the SDK Manager")
}

dependencies {
    compileOnly files(androidJar)
    implementation 'org.jetbrains:annotations-java5:15.0'

    testCompileOnly files(androidJar)
    testImplementation 'junit:junit:4.12'
}

task("generateStaticProxy", type: Exec, group: "verification") {
    def outputDir = "$buildDir/static_proxy"
    outputs.dir(outputDir)
    outputs.upToDateWhen { false }
    doFirst { delete outputDir }
    environment "PYTHONPATH", "$projectDir/../gradle-plugin/src/main/python"
    executable "python3"
    args "-m", "chaquopy.static_proxy"
    args "--path", "$projectDir/src/test/python"
    args "--java", outputDir
    args("chaquopy.test.static_proxy.basic", "chaquopy.test.static_proxy.header",
         "chaquopy.test.static_proxy.method")
}
sourceSets.test.java.srcDirs += generateStaticProxy.outputs

for (abi in ["host"] + Common.ABIS) {
    // Linux defaults
    def pyLibPrefix = ""
    def pyLibSuffix = ".so"
    def javaLibPrefix = "lib"
    def javaLibSuffix = ".so"

    def cmakeBuildSubdir = "$buildDir/cmake/$abi"
    def cmakeBuildType = findProperty("cmakeBuildType") ?: "Debug"
    def cmake = task("cmake-$abi", type: Exec, group: "build") {
        dependsOn cythonPython, cythonJava
        inputs.files "CMakeLists.txt"
        inputs.property("cmakeBuildType", cmakeBuildType)
        outputs.files "$cmakeBuildSubdir/build.ninja", "$cmakeBuildSubdir/rules.ninja",
                      "$cmakeBuildSubdir/CMakeCache.txt"
        doFirst {
            mkdir cmakeBuildSubdir
            delete(outputs.files)   // Otherwise changes to args below won't take effect
        }
        workingDir cmakeBuildSubdir
        executable "$sdkCmakeDir/bin/cmake"
        args "-GNinja", "-DCMAKE_MAKE_PROGRAM=$sdkCmakeDir/bin/ninja",
             "-DCMAKE_BUILD_TYPE=$cmakeBuildType",
             "-DCHAQUOPY_SRC_DIR=build/cython",
             "-DCHAQUOPY_LIBS=$pyPlusVersion"

        if (abi == "host") {
            if (windowsHost) {
                pyLibSuffix = ".pyd"
                javaLibPrefix = ""
                javaLibSuffix = ".dll"
                args "-DCHAQUOPY_INCLUDE_DIRS=$mingwDir/include/$pyPlusVersion;" +
                                             "$javaHome/include;$javaHome/include/win32"
            } else {
                // TODO #5482: support Mac
                args "-DCHAQUOPY_INCLUDE_DIRS=/usr/include/$pyPlusVersion;" +
                                             "$javaHome/include;$javaHome/include/linux"
            }
        } else {
            dependsOn cythonAndroid
            def prefixDir = "$projectDir/../../target/toolchains/$abi/sysroot/usr"
            args "-DCMAKE_TOOLCHAIN_FILE=$ndkDir/build/cmake/android.toolchain.cmake",
                 "-DANDROID_NDK=$ndkDir", "-DANDROID_STL=system",
                 "-DANDROID_NATIVE_API_LEVEL=$Common.MIN_SDK_VERSION", "-DANDROID_ABI=$abi",
                 "-DCHAQUOPY_INCLUDE_DIRS=$prefixDir/include/python$Common.PYTHON_SUFFIX",
                 "-DCHAQUOPY_LIB_DIRS=$prefixDir/lib"
        }
        args "-DPY_LIB_PREFIX=$pyLibPrefix", "-DPY_LIB_SUFFIX=$pyLibSuffix",
             "-DJAVA_LIB_PREFIX=$javaLibPrefix", "-DJAVA_LIB_SUFFIX=$javaLibSuffix",
             "$projectDir"
    }

    def cmakeBuild = task("cmakeBuild-$abi", type: Exec, group: "build") {
        // No inputs or outputs: the command itself determines whether it's up to date.
        dependsOn cmake
        executable "$sdkCmakeDir/bin/cmake"
        args "--build", cmakeBuildSubdir
    }
    if (abi != "host") {
        addArtifact(cmakeBuild, "$cmakeBuildSubdir/libchaquopy_java.so", abi)
        addArtifact(cmakeBuild, "$cmakeBuildSubdir/chaquopy.so", abi)
        addArtifact(cmakeBuild, "$cmakeBuildSubdir/chaquopy_android.so", abi)
    }

    if (abi == "host") {
        def mainPythonDir = "$projectDir/src/main/python"
        def testPythonDir = "$projectDir/src/test/python"
        task("setupPythonPath", group: "verification") {
            dependsOn cmakeBuild
            doFirst {
                copy {
                    into mainPythonDir
                    from(cmakeBuildSubdir) {
                        include "chaquopy${pyLibSuffix}"
                        into "java"
                    }
                }
            }
        }

        def testCommonConfig = {
            dependsOn setupPythonPath, compileTestJava
            environment "CLASSPATH", sourceSets.test.runtimeClasspath.asPath

            // Can't use -Djava.library.path because we need something which also works
            // for Python processes.
            def pathVar = windowsHost ? "PATH" : "LD_LIBRARY_PATH"
            environment pathVar, (cmakeBuildSubdir + File.pathSeparator +
                                  (System.getenv(pathVar) ?: ""))
            environment "PYTHONHOME", windowsHost ? mingwDir : "/usr"
            environment "PYTHONPATH", mainPythonDir + File.pathSeparator + testPythonDir
        }

        // For consistency with Android demo app, run via test suite rather than using
        // "discover".
        task("testPython", type: Exec, group: "verification") {
            workingDir "$projectDir/src/test/python"
            executable pyPlusVersionExe
            args "-m", "unittest"
            if (project.hasProperty("testPythonArgs")) {
                args project.testPythonArgs.split(" ")
            } else {
                args "chaquopy.test"
            }
        }
        testPython.configure(testCommonConfig)
        check.dependsOn(testPython)

        compileTestJava {
            sourceCompatibility = "1.8"
            targetCompatibility = "1.8"
        }

        // Run via test suite for consistency with Android demo app. (NOTE: this will not show
        // test results within IntelliJ for some reason.)
        test.exclude "**"  // Disable the default test task
        task("testJava", type: Test, group: "verification") {
            outputs.upToDateWhen { false }
            if (!windowsHost) {
                // libchaquopy_java.so is linked against libpython, but that doesn't add
                // the libpython symbols to the global scope, which is required in order to
                // load native modules like ctypes. Loading libpython with
                // System.loadLibrary doesn't help: presumably it uses RTLD_LOCAL on
                // Linux. Altering chaquopy_java to call dlopen with RTLD_GLOBAL would be
                // the proper solution, but let's do it the easy way for now.
                //
                // TODO #5482: support Mac
                environment "LD_PRELOAD", "/usr/lib/x86_64-linux-gnu/lib${pyPlusVersion}.so"
            }
            testClassesDirs = sourceSets.test.output.classesDirs
            scanForTestClasses = false
            include "**/TestSuite.class"
            testLogging {
                exceptionFormat = 'full'
                showStandardStreams = true
            }
        }
        testJava.configure(testCommonConfig)
        check.dependsOn(testJava)

        // Generates a script to start a Python REPL with Java and Python paths set up.
        task("consoleScript") {
            dependsOn setupPythonPath
            doLast {
                def writer = new PrintWriter("$projectDir/console.sh")
                writer.println "#!/bin/bash -e"
                writer.println "# Generated by Gradle consoleScript task"
                def env = testPython.environment
                for (String key : ["CLASSPATH", "PYTHONPATH"]) {
                    writer.println "export $key='${env.get(key)}'"
                }
                writer.println "export PATH=\"$cmakeBuildSubdir${File.pathSeparator}" + '$PATH"'
                writer.println "winpty $pyPlusVersionExe " + '"$@"'
                writer.close()
            }
        }

        task("sphinx", type: Exec, group: "documentation") {
            // We call a specific Python executable rather than running `sphinx-build`,
            // because Sphinx needs to be able to import the runtime module.
            executable pyPlusVersionExe
            args "-m", "sphinx", "-v", "-b", "html", "docs/sphinx", "build/docs"
        }
        sphinx.configure(testCommonConfig)
        doc.dependsOn(sphinx)
    }
}
