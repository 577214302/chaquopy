apply plugin: 'java'
apply plugin: 'ch.raffael.pegdown-doclet'  // For javadoc

import com.chaquo.python.Common;


configurations {
    python
    jniLibs
    libDynload
}

sourceSets.main.java.srcDirs += ["../buildSrc/src/main/java"]
sourceCompatibility = 7
archivesBaseName = "chaquopy_java"

task("zipPython", type: Zip, group: "build") {
    from fileTree("src/main/python") { include "**/*.py" }
    destinationDir buildDir
    archiveName Common.ASSET_CHAQUOPY
}
artifacts { python zipPython }


/* My attempts to use Cygwin were not successful (see commit message of 2017-04-20), so there are two
options for working on Windows:

Use the official Python Windows build, in which case you must use the appropriate Microsoft compiler
(https://wiki.python.org/moin/WindowsCompilers), because:
* Native modules must be linked against a C library compatible with the one the Python interpreter
  uses (https://bugs.python.org/issue4709#msg243605).
* The supplied C headers depend on _MSC_VER and possibly other #defines not set by any other
  compiler.

Or (as this file currently does) use MSYS2, making sure to also use their Pacman packages of pip and
setuptools and never install them from PyPI, because the standard versions assume that if you're on
Windows you must be using the Microsoft compiler. For the MSYS2 compiler to be found by cmake,
msys64/mingw64/bin should be on the PATH.

In both cases, interactive use of Python requires either using a Windows console window, or the
winpty program in mintty. And for the Python and Cython executables to be found by their Gradle
tasks, their directories must be on the PATH. */

// The following properties file should be created manually. It's also used in
// test_gradle_plugin.py.
def localProps = new Properties()
localProps.load(project.rootProject.file('local.properties').newDataInputStream())
def sdkDir = localProps.getProperty('sdk.dir')
def ndkDir = localProps.getProperty('ndk.dir')
def crystaxDir = localProps.getProperty('crystax.dir')
def mingwDir = localProps.getProperty('mingw.dir')  // Windows only

def javaHome = System.getenv("JAVA_HOME")
def windowsHost = System.properties['os.name'].toLowerCase().contains('windows')
def EXE_SUFFIX = windowsHost ? ".exe" : ""


// Affected by Markdown plugin above
javadoc {
    outputs.upToDateWhen { false }
    destinationDir = file("$docsDir/java")
    doFirst { delete(destinationDir) }
    title "Java API â€” Chaquopy"  // Consistent with Sphinx page title style
    executable "$javaHome/bin/javadoc$EXE_SUFFIX"   // Prevents some irrelevant warnings
    options {
        addBooleanOption("Xdoclint:all,-missing", true)  // Doesn't seem to have any effect within Gradle
        addStringOption("sourcepath", "$javaHome/src.zip")  // For documentation of inherited members
        addBooleanOption("nodeprecated", true)
        addStringOption("noqualifier", "all")
        addStringOption("link", "https://developer.android.com/reference/")
        addStringOption("stylesheetfile", "docs/javadoc/javadoc-chaquo.css")
        addStringOption("encoding", "UTF-8")  // For em dash in title above
    }
}

def doc = task("doc", group: "documentation")
doc.dependsOn(javadoc)


def cythonTask = {Map taskArgs, String name, Closure closure ->
    taskArgs["type"] = Exec
    def t = task(taskArgs, name, closure)
    t.configure {
        def pyxFiles = inputs.files.findAll { it.name.endsWith(".pyx") }
        assert(pyxFiles.size() == 1)
        def inFile = pyxFiles.get(0)
        def stem = inFile.name.substring(0, inFile.name.length() - ".pyx".length())
        def outFile = "$buildDir/cython/${stem}.c"

        outputs.file outFile
        workingDir inFile.parent  // Reduce clutter in exception traces
        executable "cython"
        args "-Wextra", "-Werror", inFile.name, "-o", outFile
        doLast {
            String[][] replacements = [
                // All functions called directly by the JVM must be declared JNICALL JNIEXPORT. JNIEXPORT
                // should be equivalent to Cython's "cdef public", but JNICALL does make a difference on
                // some platforms including x86. So alter the generated C code to add it.
                [/__PYX_EXTERN_C DL_EXPORT\((.+?)\)/,
                 '/* cythonTask altered */ __PYX_EXTERN_C JNIEXPORT $1 JNICALL'],

                // Reduce clutter in exception traces
                [/"%s \(%s:%d\)", funcname, __pyx_cfilenm, c_line/,
                 '/* cythonTask altered */ "%s (%s:%d)", funcname, ".c", c_line'],
            ]
            def cFile = outputs.files.getSingleFile()
            def tmpFile = new File("${cFile}.tmp")
            def replacementCount = 0
            tmpFile.withWriter { writer ->
                for (line in cFile.readLines()) {
                    for (r in replacements) {
                        line = line.replaceAll(r[0], r[1])
                    }
                    writer.write(line + "\n")
                }
            }
            if (! (cFile.delete() && tmpFile.renameTo(cFile))) {
                throw new GradleException("Failed to replace $cFile")
            }
        }

    }
    return t
}

cythonTask("cythonPython", group: "build") {
    inputs.files fileTree("$projectDir/src/main/python/java") {
        include "*.pyx", "*.pxi", "*.pxd"
    }
}
cythonTask("cythonJava", group: "build") {
    inputs.files "$projectDir/src/main/python/chaquopy_java.pyx"
    inputs.files fileTree("$projectDir/src/main/python/java") { include "*.pxd" }
    inputs.files "$projectDir/../../server/license/check_ticket.py"
}
task("cython", group: "build") {
    dependsOn cythonPython, cythonJava
}


def sdkCmakeParentDir = new File(sdkDir, "cmake")
def sdkCmakeDir = "$sdkCmakeParentDir/${sdkCmakeParentDir.list()[0]}"

def cmakeBuildAnchor = task("cmakeBuild", group: "build")
assemble.dependsOn(cmakeBuildAnchor)

def androidJar = "$sdkDir/platforms/android-$Common.MIN_SDK_VERSION/android.jar"

for (pyFullVersion in Common.PYTHON_VERSIONS) {
    def pyVersion = pyFullVersion.substring(0, pyFullVersion.lastIndexOf("."))
    for (abi in ["host"] + Common.ABIS) {
        def pyPlusVersion = "python$pyVersion${pyVersion.startsWith("3") ? "m" : ""}"   // See PEP 3149
        // filenames with dots require the ".exe" suffix with Exec tasks on Windows.
        def pyPlusVersionExe = "$pyPlusVersion$EXE_SUFFIX"

        // Linux defaults
        def pyLibPrefix = ""
        def pyLibSuffix = ".so"
        def javaLibPrefix = "lib"
        def javaLibSuffix = ".so"

        def cmakeBuildSubdir = "$buildDir/cmake/$pyVersion/$abi"
        def cmakeBuildType = findProperty("cmakeBuildType") ?: "Debug"
        def cmake = task("cmake-$pyVersion-$abi", type: Exec, group: "build") {
            dependsOn cython
            inputs.files "CMakeLists.txt"
            inputs.property("cmakeBuildType", cmakeBuildType)
            outputs.files "$cmakeBuildSubdir/build.ninja", "$cmakeBuildSubdir/rules.ninja",
                          "$cmakeBuildSubdir/CMakeCache.txt"
            doFirst {
                mkdir cmakeBuildSubdir
                delete(outputs.files)   // Otherwise changes to args below won't take effect
            }
            workingDir cmakeBuildSubdir
            executable "$sdkCmakeDir/bin/cmake"
            args "-GNinja", "-DCMAKE_MAKE_PROGRAM=$sdkCmakeDir/bin/ninja",
                 "-DCMAKE_BUILD_TYPE=$cmakeBuildType",
                 "-DCHAQUOPY_LIBS=$pyPlusVersion"

            if (abi == "host") {
                if (windowsHost) {
                    pyLibSuffix = ".pyd"
                    javaLibPrefix = ""
                    javaLibSuffix = ".dll"
                    args "-DCHAQUOPY_INCLUDE_DIRS=$mingwDir/include/$pyPlusVersion;" +
                                                 "$javaHome/include;$javaHome/include/win32"
                } else {
                    // TODO #5184 untested
                    args "-DCHAQUOPY_INCLUDE_DIRS=/usr/include/$pyPlusVersion"
                }
            } else {
                def pyDir = "$crystaxDir/sources/python/$pyVersion"
                args "-DCMAKE_TOOLCHAIN_FILE=$ndkDir/build/cmake/android.toolchain.cmake",
                     "-DANDROID_NDK=$ndkDir", "-DANDROID_STL=system",
                     "-DANDROID_NATIVE_API_LEVEL=$Common.MIN_SDK_VERSION", "-DANDROID_ABI=$abi",
                     "-DCHAQUOPY_INCLUDE_DIRS=$pyDir/include/python",
                     "-DCHAQUOPY_LIB_DIRS=$pyDir/libs/$abi"
            }
            args "-DPY_LIB_PREFIX=$pyLibPrefix", "-DPY_LIB_SUFFIX=$pyLibSuffix",
                 "-DJAVA_LIB_PREFIX=$javaLibPrefix", "-DJAVA_LIB_SUFFIX=$javaLibSuffix",
                 "$projectDir"
        }

        def cmakeBuild = task("cmakeBuild-$pyVersion-$abi", type: Exec, group: "build") {
            // No inputs or outputs: the command itself determines whether it's up to date.
            dependsOn cmake
            executable "$sdkCmakeDir/bin/cmake"
            args "--build", cmakeBuildSubdir
        }
        cmakeBuildAnchor.dependsOn(cmakeBuild)
        if (abi != "host") {
            project.artifacts {
                jniLibs    (file("$cmakeBuildSubdir/libchaquopy_java.so")) { builtBy cmakeBuild }
                libDynload (file("$cmakeBuildSubdir/chaquopy.so"))         { builtBy cmakeBuild }
            }
        }

        if (abi == "host") {
            def mainPythonDir = "$projectDir/src/main/python"
            def testPythonDir = "$projectDir/src/test/python"
            def setupPythonPath = task("setupPythonPath-$pyVersion", group: "verification") {
                dependsOn cmakeBuild
                doFirst {
                    copy {
                        into mainPythonDir
                        from(cmakeBuildSubdir) {
                            include "chaquopy${pyLibSuffix}"
                            into "java"
                        }
                    }
                }
            }

            def generateStaticProxy = task("generateStaticProxy-$pyVersion",
                                           type: Exec, group: "verification") {
                def outputDir = "$buildDir/static_proxy"
                outputs.dir(outputDir)
                outputs.upToDateWhen { false }
                doFirst { delete outputDir }
                environment "PYTHONPATH", "$projectDir/../gradle-plugin/src/main/python"
                executable pyPlusVersionExe
                args "-m", "chaquopy.static_proxy"
                args "--path", "$projectDir/src/test/python"
                args "--java", outputDir
                args "static_proxy.basic", "static_proxy.header", "static_proxy.method"
            }
            sourceSets.test.java.srcDirs += generateStaticProxy.outputs

            def testCommonConfig = {
                dependsOn setupPythonPath, compileTestJava
                environment "CLASSPATH", "$compileJava.destinationDir;$compileTestJava.destinationDir;$androidJar"
                // TODO #5184: PATH would be LD_LIBRARY_PATH on Linux. Can't use -Djava.library.path
                // because we need something which also works for Python processes.
                environment "PATH", "$cmakeBuildSubdir${File.pathSeparator}${System.getenv("PATH")}"
                environment "PYTHONHOME", windowsHost ? mingwDir : "/usr"
                environment "PYTHONPATH", "$mainPythonDir${File.pathSeparator}$testPythonDir"
            }

            // Run via test suite for consistency with Android demo app.
            def testPython = task("testPython-$pyVersion", type: Exec, group: "verification") {
                workingDir "$projectDir/src/test/python"
                executable pyPlusVersionExe
                args "-m", "unittest"
                if (project.hasProperty("testPythonArgs")) {
                    args project.testPythonArgs.split(" ")
                } else {
                    args "-v", "test_suite"
                }
            }
            testPython.configure(testCommonConfig)
            check.dependsOn(testPython)

            // Run via test suite for consistency with Android demo app.
            test {
                outputs.upToDateWhen { false }
                scanForTestClasses = false
                include "**/TestSuite.class"
                testLogging {
                    exceptionFormat = 'full'
                    showStandardStreams = true
                }
            }
            test.configure(testCommonConfig)

            // Generates a script to start a Python REPL with Java and Python paths set up.
            task("consoleScript-$pyVersion") {
                doLast {
                    def writer = new PrintWriter("$projectDir/console-${pyVersion}.sh")
                    writer.println "#!/bin/bash -e"
                    writer.println "# Generated by Gradle consoleScript task"
                    def env = testPython.environment
                    for (String key : ["CLASSPATH", "PYTHONPATH"]) {
                        writer.println "export $key='${env.get(key)}'"
                    }
                    writer.println "export PATH=\"$cmakeBuildSubdir${File.pathSeparator}" + '$PATH"'
                    writer.println "winpty $pyPlusVersionExe"
                    writer.close()
                }
            }

            if (pyVersion == "2.7") {
                task("sphinx", type: Exec, group: "documentation") {
                    executable "python"
                    args "-msphinx", "-v", "-b", "html", "docs/sphinx", "build/docs"
                }
                sphinx.configure(testCommonConfig)
                doc.dependsOn(sphinx)
            }
        }
    }
}


dependencies {
    compileOnly files(androidJar)

    // This is a library project, so use "+" notation for external dependencies.
    // However, avoid adding dependencies, because they'll inflate the size of the users' APKs.

    testCompile 'junit:junit:4.12'
}
