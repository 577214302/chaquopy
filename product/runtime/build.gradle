apply plugin: 'java'

archivesBaseName = "chaquopy-runtime"
sourceCompatibility = 7
jar {
    version = null
}


/* FIXME note install (and add to path (in this order))
MSYS2 mingw64\bin and usr\bin
Windows Python (root and Scripts) (use winpty to run it within msys2)
Oracle JDK (%JAVA_HOME%\bin), with JAVA_HOME set to root

Set MSYS2_PATH_TYPE=inherit in msys2 ini files
Set distutils compiler=unix ??

Use the official Python Windows build, and the appropriate Microsoft compiler
(https://wiki.python.org/moin/WindowsCompilers) in order to make sure that native extensions are
linked with a C library compatible with the one the Python interpreter uses
(https://bugs.python.org/issue4709#msg243605).

Or use MSYS2, making sure to also use their Pacman packages of pip and setuptools and never install
them from PyPI, because the standard versions assume that if you're on Windows you must be using the
Microsoft compiler.

My attempts to use Cygwin were not successful (see commit message of 2017-04-20. 
*/

// Currently the oldest version included in the NDK. The corresponding platform JAR should be
// manually downloaded using the SDK Manager.
final def API_LEVEL = 9

// The following properties file should be created manually.
def localProps = new Properties()
localProps.load(project.rootProject.file('local.properties').newDataInputStream())
def sdkDir = localProps.getProperty('sdk.dir')
def ndkDir = localProps.getProperty('ndk.dir')
def crystaxDir = localProps.getProperty('crystax.dir')
def javaHome = System.getenv("JAVA_HOME")
def windowsHost = System.properties['os.name'].toLowerCase().contains('windows')

task cython(type: Exec, group: "build") {
    def cythonBuildDir = "$buildDir/cython"
    def pyxDir = "$projectDir/src/main/python/jnius"
    def pyxFile = "$pyxDir/jnius.pyx"
    inputs.files pyxFile, fileTree(pyxDir) { include "*.pxi" }
    outputs.file "$cythonBuildDir/jnius.c"
    doFirst { mkdir(cythonBuildDir) }
    executable "cython"
    args pyxFile, "-o", outputs.files.getSingleFile()

    // FIXME JNICALL JNIEXPORT with forward declarations in a header file
}

def sdkCmakeParentDir = new File(sdkDir, "cmake")
def sdkCmakeDir = "$sdkCmakeParentDir/${sdkCmakeParentDir.list()[0]}"

def cmakeBuildAnchor = task("cmakeBuild", group: "build")
assemble.dependsOn(cmakeBuildAnchor)

for (pyVersion in ["2.7",/* TODO "3.5"*/]) {
    for (abi in ["host", "x86", "x86_64", "armeabi", "armeabi-v7a", "arm64-v8a"]) {
        def pyPlusVersion
        if (abi == "host" && windowsHost) {
            pyPlusVersion = "python${pyVersion.replace(".", "")}"
        } else {
            pyPlusVersion = "python$pyVersion${pyVersion.startsWith("3") ? "m" : ""}"   // See PEP 3149
        }

        def cmakeBuildSubdir = "$buildDir/cmake/$pyVersion/$abi"
        def cmake = task("cmake-$pyVersion-$abi", type: Exec, group: "build") {
            inputs.files "CMakeLists.txt"
            outputs.files "$cmakeBuildSubdir/build.ninja", "$cmakeBuildSubdir/rules.ninja"
            doFirst {
                delete(cmakeBuildSubdir)
                mkdir(cmakeBuildSubdir)
            }
            workingDir cmakeBuildSubdir
            executable "$sdkCmakeDir/bin/cmake"
            args "-GNinja", "-DCMAKE_MAKE_PROGRAM=$sdkCmakeDir/bin/ninja",
                 "-DCMAKE_BUILD_TYPE=Debug"  // TODO

            if (abi == "host") {
                if (windowsHost) {
                    def pyDir = "C:/${pyPlusVersion.capitalize()}"
                    args "-DCHAQUOPY_INCLUDE_DIRS=$pyDir/include;$javaHome/include;$javaHome/include/win32",
                         "-DCHAQUOPY_LIB_DIRS=$pyDir/libs;$javaHome/lib",   // FIXME use dlopen instead
                         "-DCHAQUOPY_LIBS=$pyPlusVersion;jvm",                //
                         "-DCHAQUOPY_SUFFIX=.pyd"
                } else {
                    throw new GradleException("Host build only supported on Windows")
                }
            } else {
                def pyDir = "$crystaxDir/sources/python/$pyVersion"
                args "-DCMAKE_TOOLCHAIN_FILE=$ndkDir/build/cmake/android.toolchain.cmake",
                     "-DANDROID_NDK=$ndkDir", "-DANDROID_STL=system",
                     "-DANDROID_NATIVE_API_LEVEL=$API_LEVEL", "-DANDROID_ABI=$abi",
                     "-DCHAQUOPY_INCLUDE_DIRS=$pyDir/include/python",
                     "-DCHAQUOPY_LIB_DIRS=$pyDir/libs/$abi",
                     "-DCHAQUOPY_LIBS=$pyPlusVersion"
            }
            args "$projectDir"
        }

        def cmakeBuild = task("cmakeBuild-$pyVersion-$abi", type: Exec, group: "build") {
            // No inputs or outputs: the command itself determines whether it's up to date.
            dependsOn cmake, cython
            executable "$sdkCmakeDir/bin/cmake"
            args "--build", cmakeBuildSubdir
        }
        cmakeBuildAnchor.dependsOn(cmakeBuild)

        if (abi == "host") {
            def testPython = task("testPython-$pyVersion", type: Exec, group: "verification") {
                dependsOn cmakeBuild, "compileTestJava"
                environment "PYTHONPATH", "$projectDir/src/main/python"
                environment "CLASSPATH", "$compileJava.destinationDir;$compileTestJava.destinationDir"
                environment "PATH", "$javaHome/jre/bin/server;${System.getenv("PATH")}" // FIXME use dlopen instead
                executable pyPlusVersion
                args "-m", "unittest", "discover", "-v", "-s", "$projectDir/src/test/python"
            }
            check.dependsOn(testPython)
        }
    }

}


dependencies {
    compile files("$sdkDir/platforms/android-$API_LEVEL/android.jar")

    // This is a library project, so use "+" notation for external dependencies.
    // However, avoid adding dependencies, because they'll inflate the size of the users' APKs.

    testCompile 'junit:junit:4.11'
}
