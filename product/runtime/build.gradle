apply plugin: 'java'
apply plugin: 'ch.raffael.pegdown-doclet'  // For javadoc

import com.chaquo.python.Common;


configurations {
    // Can't use "compile" or anything based on it, because it contains android.jar. Can't use
    // "archives" because it somehow ends up containing everything from all the other configurations
    // as well.
    chaquopyJava

    chaquopyPython
    jniLibs
    libDynload
}
artifacts { chaquopyJava jar }

sourceSets.main.java.srcDirs += ["../buildSrc/src/main/java"]
sourceCompatibility = 7
archivesBaseName = "chaquopy_java"

task("zipPython", type: Zip, group: "build") {
    from fileTree("src/main/python") {
        include "**/*.py"
        include "**/*.dist-info/**"  // For license files
        includeEmptyDirs false
    }
    destinationDir buildDir
    archiveName Common.ASSET_BOOTSTRAP
}
artifacts { chaquopyPython zipPython }


// The following properties file should be created manually. It's also used in
// test_gradle_plugin.py.
String getLocalProperty(String key, String defaultValue = null) {
    def localProps = new Properties()
    localProps.load(project.rootProject.file('local.properties').newDataInputStream())
    def result = localProps.getProperty(key, defaultValue)
    if (result == null) {
        throw new GradleException("'$key' is missing from local.properties")
    }
    return result
}

def sdkDir = getLocalProperty('sdk.dir')
def ndkDir = getLocalProperty('ndk.dir')
def crystaxDir = getLocalProperty('crystax.dir')
def licenseMode = getLocalProperty('chaquopy.license_mode', '')
def javaHome = System.getProperty("java.home")

def windowsHost = System.properties['os.name'].toLowerCase().contains('windows')
def EXE_SUFFIX = windowsHost ? ".exe" : ""
def mingwDir = windowsHost ? getLocalProperty('mingw.dir') : null


// Affected by Markdown plugin above
javadoc {
    outputs.upToDateWhen { false }
    destinationDir = file("$docsDir/java")
    doFirst { delete(destinationDir) }
    title "Java API â€” Chaquopy"  // Consistent with Sphinx page title style
    executable "$javaHome/bin/javadoc$EXE_SUFFIX"   // Prevents some irrelevant warnings
    options {
        addBooleanOption("Xdoclint:all,-missing", true)  // Doesn't seem to have any effect within Gradle
        addStringOption("sourcepath", "$javaHome/src.zip")  // For documentation of inherited members
        addBooleanOption("nodeprecated", true)
        addStringOption("noqualifier", "all")
        addStringOption("link", "https://developer.android.com/reference/")
        addStringOption("stylesheetfile", "docs/javadoc/javadoc-chaquo.css")
        addStringOption("encoding", "UTF-8")  // For em dash in title above
    }
}

def doc = task("doc", group: "documentation")
doc.dependsOn(javadoc)


def cythonTask = {Map taskArgs=[:], String name, Closure closure ->
    taskArgs["type"] = Exec
    taskArgs.putIfAbsent("group", "build")
    def t = task(taskArgs, name, closure)
    t.configure {
        def pyxFiles = inputs.files.findAll { it.name.endsWith(".pyx") }
        assert(pyxFiles.size() == 1)
        def inFile = pyxFiles.get(0)
        def stem = inFile.name.substring(0, inFile.name.length() - ".pyx".length())
        def outDir = "$buildDir/cython"
        def outFile = "$outDir/${stem}.c"
        outputs.file outFile

        doFirst {
            file("$outDir/build.pxi").text = "DEF CHAQUOPY_LICENSE_MODE = \"$licenseMode\""
        }
        workingDir inFile.parent  // Reduce clutter in exception traces
        executable "cython"
        args "-Wextra", "-Werror", inFile.name, "-I", outDir, "-o", outFile
        if (! licenseMode.isEmpty()) {
            args "-X", "emit_code_comments=False"
        }

        doLast {
            String[][] replacements = [
                // All functions called directly by the JVM must be declared JNICALL JNIEXPORT. JNIEXPORT
                // should be equivalent to Cython's "cdef public", but JNICALL does make a difference on
                // some platforms including x86. So alter the generated C code to add it.
                [/^__PYX_EXTERN_C (\w+)/,
                 '/* cythonTask altered */ __PYX_EXTERN_C JNIEXPORT $1 JNICALL'],
            ]
            def cFile = outputs.files.getSingleFile()
            def tmpFile = new File("${cFile}.tmp")
            def replacementCount = 0
            tmpFile.withWriter { writer ->
                for (line in cFile.readLines()) {
                    for (r in replacements) {
                        line = line.replaceAll(r[0], r[1])
                    }
                    writer.write(line + "\n")
                }
            }
            if (! (cFile.delete() && tmpFile.renameTo(cFile))) {
                throw new GradleException("Failed to replace $cFile")
            }
        }

    }
    return t
}

cythonTask("cythonPython") {
    inputs.files fileTree("$projectDir/src/main/python/java") {
        include "*.pyx", "*.pxi", "*.pxd"
    }
    inputs.property("licenseMode", licenseMode)
    if (licenseMode.isEmpty()) {
        inputs.files "$projectDir/../../server/license/check_ticket.py"
    }
}
cythonTask("cythonJava") {
    inputs.files "$projectDir/src/main/python/chaquopy_java.pyx"
    inputs.files fileTree("$projectDir/src/main/python/java") { include "*.pxd" }
}


def sdkCmakeParentDir = new File(sdkDir, "cmake")
def sdkCmakeDir = "$sdkCmakeParentDir/${sdkCmakeParentDir.list()[0]}"
def androidJar = "$sdkDir/platforms/android-$Common.COMPILE_SDK_VERSION/android.jar"

dependencies {
    compileOnly files(androidJar)
    testCompileOnly files(androidJar)

    // This is a library project, so use "+" notation for external dependencies.
    // However, avoid adding dependencies, because they'll inflate the size of the users' APKs.

    testCompile 'junit:junit:4.12'
}

task("generateStaticProxy", type: Exec, group: "verification") {
    def outputDir = "$buildDir/static_proxy"
    outputs.dir(outputDir)
    outputs.upToDateWhen { false }
    doFirst { delete outputDir }
    environment "PYTHONPATH", "$projectDir/../gradle-plugin/src/main/python"
    executable "python"
    args "-m", "chaquopy.static_proxy"
    args "--path", "$projectDir/src/test/python"
    args "--java", outputDir
    args("chaquopy.test.static_proxy.basic", "chaquopy.test.static_proxy.header",
         "chaquopy.test.static_proxy.method")
}
sourceSets.test.java.srcDirs += generateStaticProxy.outputs

task("testPython", "group": "verification")
task("testJava", "group": "verification")

def prevPyVersion = null
for (pyFullVersion in Common.PYTHON_VERSIONS) {
    def pyVersion = Common.pyVersionShort(pyFullVersion)
    if (prevPyVersion != null && pyVersion.equals(prevPyVersion)) continue
    def testVer = task("test-$pyVersion", "group": "verification")
    check.dependsOn(testVer)

    for (abi in ["host"] + Common.ABIS) {
        def pyPlusVersion = "python${Common.PYTHON_SUFFIXES.get(pyVersion)}"
        // filenames with dots require the ".exe" suffix with Exec tasks on Windows.
        def pyPlusVersionExe = "$pyPlusVersion$EXE_SUFFIX"

        // Linux defaults
        def pyLibPrefix = ""
        def pyLibSuffix = ".so"
        def javaLibPrefix = "lib"
        def javaLibSuffix = ".so"

        def cmakeBuildSubdir = "$buildDir/cmake/$pyVersion/$abi"
        def cmakeBuildType = findProperty("cmakeBuildType") ?: "Debug"
        def cmake = task("cmake-$pyVersion-$abi", type: Exec, group: "build") {
            dependsOn cythonPython, cythonJava
            inputs.files "CMakeLists.txt"
            inputs.property("cmakeBuildType", cmakeBuildType)
            outputs.files "$cmakeBuildSubdir/build.ninja", "$cmakeBuildSubdir/rules.ninja",
                          "$cmakeBuildSubdir/CMakeCache.txt"
            doFirst {
                mkdir cmakeBuildSubdir
                delete(outputs.files)   // Otherwise changes to args below won't take effect
            }
            workingDir cmakeBuildSubdir
            executable "$sdkCmakeDir/bin/cmake"
            args "-GNinja", "-DCMAKE_MAKE_PROGRAM=$sdkCmakeDir/bin/ninja",
                 "-DCMAKE_BUILD_TYPE=$cmakeBuildType",
                 "-DCHAQUOPY_LIBS=$pyPlusVersion"

            if (abi == "host") {
                if (windowsHost) {
                    pyLibSuffix = ".pyd"
                    javaLibPrefix = ""
                    javaLibSuffix = ".dll"
                    args "-DCHAQUOPY_INCLUDE_DIRS=$mingwDir/include/$pyPlusVersion;" +
                                                 "$javaHome/include;$javaHome/include/win32"
                } else {
                    // TODO #5482: support Mac
                    args "-DCHAQUOPY_INCLUDE_DIRS=/usr/include/$pyPlusVersion;" +
                                                 "$javaHome/include;$javaHome/include/linux"
                }
            } else {
                def pyDir = "$crystaxDir/sources/python/$pyVersion"
                args "-DCMAKE_TOOLCHAIN_FILE=$ndkDir/build/cmake/android.toolchain.cmake",
                     "-DANDROID_NDK=$ndkDir", "-DANDROID_STL=system",
                     "-DANDROID_NATIVE_API_LEVEL=$Common.MIN_SDK_VERSION", "-DANDROID_ABI=$abi",
                     "-DCHAQUOPY_INCLUDE_DIRS=$pyDir/include/python",
                     "-DCHAQUOPY_LIB_DIRS=$pyDir/libs/$abi"
            }
            args "-DPY_LIB_PREFIX=$pyLibPrefix", "-DPY_LIB_SUFFIX=$pyLibSuffix",
                 "-DJAVA_LIB_PREFIX=$javaLibPrefix", "-DJAVA_LIB_SUFFIX=$javaLibSuffix",
                 "$projectDir"
        }

        def cmakeBuild = task("cmakeBuild-$pyVersion-$abi", type: Exec, group: "build") {
            // No inputs or outputs: the command itself determines whether it's up to date.
            dependsOn cmake
            executable "$sdkCmakeDir/bin/cmake"
            args "--build", cmakeBuildSubdir
        }
        if (abi != "host") {
            project.artifacts {
                jniLibs    (file("$cmakeBuildSubdir/libchaquopy_java.so")) { builtBy cmakeBuild }
                libDynload (file("$cmakeBuildSubdir/chaquopy.so"))         { builtBy cmakeBuild }
            }
        }

        if (abi == "host") {
            def mainPythonDir = "$projectDir/src/main/python"
            def testPythonDir = "$projectDir/src/test/python"
            def setupPythonPath = task("setupPythonPath-$pyVersion", group: "verification") {
                dependsOn cmakeBuild
                if (prevPyVersion != null) {
                    mustRunAfter(tasks.getByName("testJava-$prevPyVersion"))
                    mustRunAfter(tasks.getByName("testPython-$prevPyVersion"))
                }
                doFirst {
                    copy {
                        into mainPythonDir
                        from(cmakeBuildSubdir) {
                            include "chaquopy${pyLibSuffix}"
                            into "java"
                        }
                    }
                }
            }

            def testCommonConfig = {
                dependsOn setupPythonPath, compileTestJava
                environment "CLASSPATH", sourceSets.test.runtimeClasspath.asPath

                // Can't use -Djava.library.path because we need something which also works
                // for Python processes.
                def pathVar = windowsHost ? "PATH" : "LD_LIBRARY_PATH"
                environment pathVar, (cmakeBuildSubdir + File.pathSeparator +
                                      (System.getenv(pathVar) ?: ""))
                environment "PYTHONHOME", windowsHost ? mingwDir : "/usr"
                environment "PYTHONPATH", mainPythonDir + File.pathSeparator + testPythonDir
            }

            // For consistency with Android demo app, run via test suite rather than using
            // "discover".
            def testPythonVer = task("testPython-$pyVersion", type: Exec, group: "verification") {
                workingDir "$projectDir/src/test/python"
                executable pyPlusVersionExe
                args "-m", "unittest"
                if (project.hasProperty("testPythonArgs")) {
                    args project.testPythonArgs.split(" ")
                } else {
                    args "chaquopy.test"
                }
            }
            testPythonVer.configure(testCommonConfig)
            testPython.dependsOn(testPythonVer)
            testVer.dependsOn(testPythonVer)

            // Run via test suite for consistency with Android demo app. (NOTE: this will not show
            // test results within IntelliJ for some reason.)
            test.exclude "**"  // Disable the default test task
            def testJavaVer = task("testJava-$pyVersion", type: Test, group: "verification") {
                outputs.upToDateWhen { false }
                if (!windowsHost) {
                    // libchaquopy_java.so is linked against libpython, but that doesn't add
                    // the libpython symbols to the global scope, which is required in order to
                    // load native modules like ctypes. Loading libpython with
                    // System.loadLibrary doesn't help: presumably it uses RTLD_LOCAL on
                    // Linux. Altering chaquopy_java to call dlopen with RTLD_GLOBAL would be
                    // the proper solution, but let's do it the easy way for now.
                    //
                    // TODO #5482: support Mac
                    environment "LD_PRELOAD", "/usr/lib/x86_64-linux-gnu/lib${pyPlusVersion}.so"
                }
                testClassesDirs = sourceSets.test.output.classesDirs
                scanForTestClasses = false
                include "**/TestSuite.class"
                testLogging {
                    exceptionFormat = 'full'
                    showStandardStreams = true
                }
            }
            testJavaVer.configure(testCommonConfig)
            testJava.dependsOn(testJavaVer)
            testVer.dependsOn(testJavaVer)

            // Generates a script to start a Python REPL with Java and Python paths set up.
            task("consoleScript-$pyVersion") {
                dependsOn setupPythonPath
                doLast {
                    def writer = new PrintWriter("$projectDir/console-${pyVersion}.sh")
                    writer.println "#!/bin/bash -e"
                    writer.println "# Generated by Gradle consoleScript task"
                    def env = testPythonVer.environment
                    for (String key : ["CLASSPATH", "PYTHONPATH"]) {
                        writer.println "export $key='${env.get(key)}'"
                    }
                    writer.println "export PATH=\"$cmakeBuildSubdir${File.pathSeparator}" + '$PATH"'
                    writer.println "winpty $pyPlusVersionExe " + '"$@"'
                    writer.close()
                }
            }

            if (pyVersion == "2.7") {
                task("sphinx", type: Exec, group: "documentation") {
                    executable pyPlusVersionExe
                    args "-m", "sphinx", "-v", "-b", "html", "docs/sphinx", "build/docs"
                }
                sphinx.configure(testCommonConfig)
                doc.dependsOn(sphinx)
            }
        }
    }
    prevPyVersion = pyVersion
}
